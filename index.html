<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Fishing Splash</title>

<style>
*{box-sizing:border-box}
html,body{margin:0;height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#fff}
body{
  background:
    url("assets/bg.jpg") center / cover no-repeat,
    linear-gradient(180deg,#061a25,#0b3a52);
}
.app{max-width:900px;margin:auto;padding:12px;padding-bottom:92px}

/* header */
.header{background:rgba(0,0,0,.45);border-radius:18px;padding:14px;margin-bottom:12px;backdrop-filter:blur(6px)}
.title{font-size:22px;font-weight:900}
.sub{font-size:13px;opacity:.85}

/* stats */
.stats{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.pill{padding:6px 10px;background:rgba(0,0,0,.45);border-radius:999px;font-size:14px}

/* ladder (free spins only) */
.ladderWrap{
  margin-top:10px;padding:10px;border-radius:16px;
  background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.10);
  backdrop-filter:blur(6px);display:none;
}
.ladderRow{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
.stage{border-radius:14px;padding:10px;background:rgba(0,0,0,.30);border:1px solid rgba(255,255,255,.08)}
.stageTop{display:flex;justify-content:space-between;align-items:center;font-size:12px;opacity:.9;margin-bottom:8px}
.stageTop b{font-size:13px;opacity:1}
.pips{display:grid;grid-template-columns:repeat(4,1fr);gap:6px}
.pip{
  height:30px;border-radius:10px;background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.10);
  display:flex;align-items:center;justify-content:center;overflow:hidden;opacity:.55
}
.pip img{width:24px;height:24px;object-fit:contain;filter:drop-shadow(0 6px 10px rgba(0,0,0,.55))}
.pip.on{opacity:1;background:linear-gradient(180deg, rgba(255,207,90,.95), rgba(217,166,44,.9))}
.stage.active{outline:2px solid rgba(255,207,90,.65)}
.stage.locked{opacity:.65}

/* reels */
.reels{background:rgba(0,0,0,.35);border-radius:20px;padding:14px;backdrop-filter:blur(6px)}
.grid{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
.cell{
  height:90px;border-radius:16px;background:rgba(0,0,0,.35);
  display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative
}
.cell img{width:64px;height:64px;object-fit:contain;filter:drop-shadow(0 8px 14px rgba(0,0,0,.7))}

/* cashfish value badge */
.valueBadge{
  position:absolute;bottom:6px;right:6px;padding:2px 6px;border-radius:999px;
  font-size:12px;font-weight:900;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.15);
  display:none
}

/* blur spin effect */
.spinning img{animation:spinMove .1s infinite linear;filter:blur(2px)}
@keyframes spinMove{from{transform:translateY(-6px)}to{transform:translateY(6px)}}
.stop img{animation:stopBounce .18s ease-out}
@keyframes stopBounce{0%{transform:translateY(-10px)}60%{transform:translateY(3px)}100%{transform:translateY(0)}}

/* message */
.msg{margin-top:10px;padding:10px;background:rgba(0,0,0,.45);border-radius:14px;font-size:14px}

/* controls */
.controls{
  margin-top:12px;background:rgba(0,0,0,.45);border-radius:20px;padding:12px;
  display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px
}
.btn{padding:12px 16px;border-radius:16px;border:none;background:rgba(255,255,255,.15);color:#fff;font-size:15px}
.spin{background:linear-gradient(180deg,#ffcf5a,#d9a62c);color:#000;font-weight:900;min-width:160px}

/* bonus intro overlay */
.overlay{
  position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:18px;
  background:rgba(0,0,0,.75);backdrop-filter:blur(6px);z-index:9999
}
.overlayCard{
  width:min(520px,100%);border-radius:20px;padding:18px;background:rgba(20,30,40,.95);
  border:1px solid rgba(255,255,255,.12);box-shadow:0 20px 60px rgba(0,0,0,.6);text-align:center
}
.overlayTitle{font-size:26px;font-weight:1000;letter-spacing:1px}
.overlaySub{opacity:.9;margin-top:8px;line-height:1.35;font-size:14px}
.bigPillRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin:14px 0}
.bigPill{
  background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.10);
  padding:10px 12px;border-radius:999px;font-weight:800
}
.primaryBtn{
  margin-top:10px;width:100%;padding:14px 16px;border:none;border-radius:16px;
  font-size:16px;font-weight:1000;background:linear-gradient(180deg,#ffcf5a,#d9a62c);color:#000
}

/* big/mega win overlay */
.winOverlay{
  position:fixed;inset:0;display:none;align-items:center;justify-content:center;
  background:rgba(0,0,0,.72);backdrop-filter:blur(6px);z-index:9998
}
.winCard{
  width:min(520px,92vw);border-radius:24px;padding:18px;background:rgba(20,30,40,.96);
  border:1px solid rgba(255,255,255,.12);box-shadow:0 20px 60px rgba(0,0,0,.6);text-align:center
}
.winType{font-size:34px;font-weight:1100;letter-spacing:1px}
.winAmt{margin-top:8px;font-size:40px;font-weight:1100}
.winHint{margin-top:10px;opacity:.85;font-size:13px}

/* bottom bar */
.bottomBar{
  position:fixed;left:0;right:0;bottom:0;
  padding:10px 12px max(10px, env(safe-area-inset-bottom));
  background:rgba(0,0,0,.55);backdrop-filter:blur(8px);
  border-top:1px solid rgba(255,255,255,.12);z-index:9000
}
.bottomInner{
  max-width:900px;margin:0 auto;display:flex;align-items:center;justify-content:space-between;gap:12px
}
.winBlock{display:flex;flex-direction:column;gap:2px}
.winLabel{font-size:12px;opacity:.85;letter-spacing:.6px}
.winValue{font-size:22px;font-weight:1000}
.fsInfo{text-align:right;font-size:12px;opacity:.9}
.fsInfo b{font-size:14px;opacity:1}
</style>
</head>
  <body>

<!-- BONUS INTRO -->
<div class="overlay" id="bonusOverlay">
  <div class="overlayCard">
    <div class="overlayTitle">BONUS FEATURE!</div>
    <div class="overlaySub">
      Triggered by <b>3+ Scatters</b> ðŸŽ£<br>
      Cashfish have values. <b>Collector</b> (rare) collects them.<br>
      Fill the ladder: 4 = x2 (+10 FS), 8 = x3 (+10 FS).
    </div>
    <div class="bigPillRow">
      <div class="bigPill">Free Spins: <span id="introFS">10</span></div>
      <div class="bigPill">Multiplier: <span id="introMult">x1</span></div>
    </div>
    <button class="primaryBtn" onclick="startBonusFromIntro()">START FREE SPINS</button>
  </div>
</div>

<!-- BIG / MEGA WIN -->
<div class="winOverlay" id="winOverlay">
  <div class="winCard">
    <div class="winType" id="winType">BIG WIN</div>
    <div class="winAmt" id="winAmt">Â£0</div>
    <div class="winHint">Tap anywhere to continue</div>
  </div>
</div>

<div class="app">

  <div class="header">
    <div class="title">FISHING SPLASH</div>
    <div class="sub">Cluster Pays Â· Bonus Intro Â· Free Spins Â· Collect</div>

    <div class="stats">
      <div class="pill">Mode: <span id="mode">Base</span></div>
      <div class="pill">FS: <span id="fs">0</span></div>
      <div class="pill">Mult: <span id="mult">x1</span></div>
      <div class="pill">Collectors: <span id="colCount">0</span></div>
      <div class="pill">Balance: <span id="bal">10000</span></div>
      <div class="pill">Bet: <span id="bet">100</span></div>
    </div>

    <!-- COLLECTOR LADDER (FREE SPINS ONLY) -->
    <div class="ladderWrap" id="ladderWrap">
      <div class="ladderRow">
        <div class="stage" id="stage1">
          <div class="stageTop"><b>x1</b> <span>0â€“3</span></div>
          <div class="pips" id="pips1"></div>
        </div>
        <div class="stage locked" id="stage2">
          <div class="stageTop"><b>x2</b> <span>4â€“7</span></div>
          <div class="pips" id="pips2"></div>
        </div>
        <div class="stage locked" id="stage3">
          <div class="stageTop"><b>x3</b> <span>8+</span></div>
          <div class="pips" id="pips3"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="reels">
    <div class="grid" id="grid"></div>
    <div class="msg" id="msg">Tap SPIN to start (music unlocks on first tap)</div>
  </div>

  <div class="controls">
    <div>
      <button class="btn" onclick="bet=Math.max(50,bet-50);update()">-</button>
      <button class="btn" onclick="bet+=50;update()">+</button>
    </div>
    <button class="btn spin" onclick="startGame()">SPIN</button>
  </div>

</div>

<!-- BOTTOM BAR -->
<div class="bottomBar">
  <div class="bottomInner">
    <div class="winBlock">
      <div class="winLabel">WIN</div>
      <div class="winValue" id="barWin">Â£0</div>
    </div>
    <div class="fsInfo" id="barInfo">READY</div>
  </div>
</div>   
<script>
/* ================== CONFIG ================== */
const COLS = 5, ROWS = 3;

/* reel timing */
const REEL_START_SPIN_MS = 380;   // overall spin start
const REEL_GAP_MS        = 210;   // time between reel stops
const SYMBOL_CYCLE_MS    = 55;    // cycle speed while spinning (lower = faster)

/* cashfish values (LOW) in BET units (bet=100 => 0.05=Â£5) */
const CASHFISH_VALUES_IN_BET = [0.05,0.08,0.1,0.12,0.15,0.2,0.25,0.3,0.4,0.5,0.75,1];

/* big / mega win thresholds (x bet) */
const BIG_WIN_X  = 20;
const MEGA_WIN_X = 50;

/* collector ladder */
const COLLECTORS_FOR_X2 = 4;
const COLLECTORS_FOR_X3 = 8;
const EXTRA_FS_ON_MILESTONE = 10;

/* collector frequency (FREE SPINS only) */
const COLLECTOR_SPAWN_CHANCE_FS = 0.08; // lower = harder

/* bonus */
const BONUS_START_FS = 10;
const TEASE_MAX_RESPINS = 1;

/* SYMBOL POOLS
   - Base: NO cashfish / collector (prevents weird base behavior)
   - FreeSpins: cashfish + rare collector
*/
const symbolsBase = [
  "A","K","Q","J","10",
  "rod","boat","tackle","hook",
  "wild","scatter"
];

const symbolsFS = [
  "A","K","Q","J","10",
  "rod","boat","tackle","hook",
  "wild",
  "cashfish","cashfish","cashfish","cashfish", // weighted
  "scatter"
];

/* ================== STATE ================== */
let balance = 10000;
let bet     = 100;
let lastWin = 0;

let mode = "Base";
let freeSpinsLeft = 0;
let bonusMultiplier = 1;
let bonusCollectorCount = 0;

let spinning = false;
let audioUnlocked = false;
let teaseRespinsUsed = 0;
let bonusIntroPending = false;

/* per spin context */
let spinCtx = { hasCollector:false, spawnCollector:false };

/* reel cycle timers (one per reel/column) */
let reelCycleTimers = new Array(COLS).fill(null);

/* ================== DOM ================== */
const grid = document.getElementById("grid");
const msg  = document.getElementById("msg");
const ladderWrap = document.getElementById("ladderWrap");

const barWin  = document.getElementById("barWin");
const barInfo = document.getElementById("barInfo");

const bonusOverlay = document.getElementById("bonusOverlay");
const winOverlay   = document.getElementById("winOverlay");
const winTypeEl    = document.getElementById("winType");
const winAmtEl     = document.getElementById("winAmt");

/* ladder elements */
const stage1=document.getElementById("stage1");
const stage2=document.getElementById("stage2");
const stage3=document.getElementById("stage3");
const pips1=document.getElementById("pips1");
const pips2=document.getElementById("pips2");
const pips3=document.getElementById("pips3");

/* ================== AUDIO ================== */
const audio = {
  bg:    new Audio("assets/audio/bg.mp3"),
  bonus: new Audio("assets/audio/bonus.mp3"),
  spin:  new Audio("assets/audio/spin.mp3"),
};
audio.bg.loop=true;    audio.bg.volume=0.4;
audio.bonus.loop=true; audio.bonus.volume=0.45;
audio.spin.volume=0.6;

function safePlay(a){ a.play().catch(()=>{}); }
function safePause(a){ try{a.pause()}catch(e){} }

/* ================== HELPERS ================== */
function randFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function setCellSymbol(cell, sym){
  const img = cell.querySelector("img");
  img.src = "assets/symbols/" + sym + ".png?v=" + Math.random();
  cell.dataset.sym = sym;

  // value badges ONLY in Free Spins
  const badge = cell.querySelector(".valueBadge");
  badge.style.display = "none";
  cell.dataset.val = "";

  if(mode==="FreeSpins" && sym==="cashfish"){
    const units = randFrom(CASHFISH_VALUES_IN_BET);
    const value = Math.round(units * bet);
    cell.dataset.val = value;
    badge.textContent = "Â£" + value;
    badge.style.display = "block";
  }
}

function countSymbol(sym){
  let n=0;
  [...grid.children].forEach(c=>{ if(c.dataset.sym===sym) n++; });
  return n;
}

/* ================== LADDER UI ================== */
function buildPips(el){
  el.innerHTML="";
  for(let i=0;i<4;i++){
    const d=document.createElement("div");
    d.className="pip";
    const img=document.createElement("img");
    img.src="assets/symbols/collector.png";
    d.appendChild(img);
    el.appendChild(d);
  }
}
buildPips(pips1); buildPips(pips2); buildPips(pips3);

function setPips(el,count){
  [...el.children].forEach((p,i)=>p.classList.toggle("on",i<count));
}

function updateLadder(){
  ladderWrap.style.display = (mode==="FreeSpins") ? "block" : "none";
  if(mode!=="FreeSpins") return;

  const c = bonusCollectorCount;

  stage1.classList.remove("active");
  stage2.classList.remove("active");
  stage3.classList.remove("active");

  stage2.classList.toggle("locked", c < 4);
  stage3.classList.toggle("locked", c < 8);

  if(c < 4){
    stage1.classList.add("active");
    setPips(pips1, c); setPips(pips2, 0); setPips(pips3, 0);
  }else if(c < 8){
    stage2.classList.add("active");
    setPips(pips1, 4); setPips(pips2, c-4); setPips(pips3, 0);
  }else{
    stage3.classList.add("active");
    setPips(pips1, 4); setPips(pips2, 4); setPips(pips3, c-8);
  }
}

/* ================== UI UPDATE ================== */
function update(){
  document.getElementById("bal").textContent = balance;
  document.getElementById("bet").textContent = bet;
  document.getElementById("mode").textContent = (mode==="FreeSpins" ? "Free Spins" : "Base");
  document.getElementById("fs").textContent = freeSpinsLeft;
  document.getElementById("mult").textContent = "x"+bonusMultiplier;
  document.getElementById("colCount").textContent = bonusCollectorCount;

  barInfo.innerHTML = (mode==="FreeSpins")
    ? `FREE SPINS <b>${freeSpinsLeft}</b> Â· x${bonusMultiplier}`
    : "READY";

  updateLadder();
}

/* ================== GRID ================== */
function createGrid(){
  grid.innerHTML="";
  for(let i=0;i<COLS*ROWS;i++){
    const c=document.createElement("div");
    c.className="cell";
    c.innerHTML="<img><div class='valueBadge'></div>";
    grid.appendChild(c);
    setCellSymbol(c, randFrom(symbolsBase));
  }
  barWin.textContent="Â£0";
}

/* ================== BONUS ================== */
function showBonusIntro(){
  document.getElementById("introFS").textContent = BONUS_START_FS;
  document.getElementById("introMult").textContent = "x1";
  bonusOverlay.style.display="flex";
}

function startBonusFromIntro(){
  bonusOverlay.style.display="none";
  safePause(audio.bg);
  safePlay(audio.bonus);

  mode="FreeSpins";
  freeSpinsLeft = BONUS_START_FS;
  bonusMultiplier = 1;
  bonusCollectorCount = 0;
  bonusIntroPending = false;

  msg.textContent="BONUS START!";
  update();
  setTimeout(()=>spin(), 650);
}

function endBonus(){
  mode="Base";
  freeSpinsLeft = 0;
  bonusMultiplier = 1;
  safePause(audio.bonus);
  safePlay(audio.bg);
  msg.textContent="Bonus complete.";
  update();
}

/* ================== WIN COUNT-UP ================== */
let winRAF=null;
const COUNTUP_MS = 650;

function animateWinTo(target){
  if(winRAF) cancelAnimationFrame(winRAF);

  const start = Number((barWin.textContent||"Â£0").replace("Â£","")) || 0;
  const t0 = performance.now();

  function frame(t){
    const p = Math.min(1,(t-t0)/COUNTUP_MS);
    const eased = 1 - Math.pow(1-p,3);
    const v = Math.round(start + (target-start)*eased);
    barWin.textContent = "Â£"+v;
    if(p<1) winRAF=requestAnimationFrame(frame);
    else winRAF=null;
  }
  winRAF=requestAnimationFrame(frame);
}

/* ================== BIG / MEGA WIN ================== */
function showWinOverlay(type, amount){
  winTypeEl.textContent = type;
  winAmtEl.textContent  = "Â£"+amount;
  winOverlay.style.display="flex";

  const close=()=>{
    winOverlay.style.display="none";
    winOverlay.removeEventListener("click",close);
  };
  winOverlay.addEventListener("click",close);
}

function maybeBigWinOverlay(amount){
  const x = amount / bet;
  if(x >= MEGA_WIN_X) showWinOverlay("MEGA WIN", amount);
  else if(x >= BIG_WIN_X) showWinOverlay("BIG WIN", amount);
}

/* ================== TEASE RESPIN ==================
   2 scatters ONLY in reels 1â€“4 (col 0..3) and rows 1â€“2 (row 0..1)
*/
function teaseConditionMet(){
  const scat=[];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const s = grid.children[r*COLS+c].dataset.sym;
      if(s==="scatter") scat.push({r,c});
    }
  }
  if(scat.length !== 2) return false;
  return scat.every(p => p.c<=3 && p.r<=1);
}

/* ================== CLUSTER PAYS (BASE) ==================
   - 5+ touching (4-direction)
   - wild counts as matching any symbol
   - scatter/cashfish/collector don't pay in base
*/
const CLUSTER_PAYS = {
  A:  [0,0,0,0,0.15,0.3,0.45,0.7,1,1.3],
  K:  [0,0,0,0,0.2,0.4,0.6,1,1.4,2],
  Q:  [0,0,0,0,0.25,0.5,0.8,1.2,1.8,2.6],
  J:  [0,0,0,0,0.3,0.6,1,1.5,2.2,3.2],
  "10":[0,0,0,0,0.35,0.7,1.2,1.8,2.6,3.8],
  rod:    [0,0,0,0,0.8,1.6,2.6,4,6,9],
  boat:   [0,0,0,0,1,2,3.5,5.5,8,12],
  tackle: [0,0,0,0,1.2,2.5,4.5,7,10,15],
  hook:   [0,0,0,0,1.4,3,5.5,8.5,12,18]
};

function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
function key(r,c){ return r+"-"+c; }

function getClusters(){
  const visited=new Set();
  const clusters=[];

  function matches(sym, cellSym){
    if(cellSym==="scatter" || cellSym==="cashfish" || cellSym==="collector") return false;
    return cellSym===sym || cellSym==="wild";
  }

  function dfs(sym,r,c,acc){
    const k=key(r,c);
    if(visited.has(k)) return;
    const cell=grid.children[r*COLS+c];
    const s=cell?.dataset.sym;
    if(!matches(sym,s)) return;

    visited.add(k);
    acc.push({r,c,idx:r*COLS+c});

    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(inBounds(nr,nc)) dfs(sym,nr,nc,acc);
    }
  }

  for(const sym of Object.keys(CLUSTER_PAYS)){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell=grid.children[r*COLS+c];
        const s=cell.dataset.sym;
        if(!matches(sym,s)) continue;

        const k=key(r,c);
        if(visited.has(k)) continue;

        const acc=[];
        dfs(sym,r,c,acc);

        if(acc.length>=5){
          clusters.push({sym, cells:acc});
        }else{
          acc.forEach(p=>visited.delete(key(p.r,p.c)));
        }
      }
    }
  }

  return clusters;
}

function evaluateClustersWin(){
  const clusters=getClusters();
  let total=0;

  for(const cl of clusters){
    const pay=CLUSTER_PAYS[cl.sym];
    if(!pay) continue;
    const size=Math.min(cl.cells.length, pay.length-1);
    const betUnits = pay[size] || 0;
    total += Math.round(betUnits * bet);
  }
  return total;
}

/* ================== FREE SPINS COLLECT ================== */
function collectCashfishIfCollectorPresent(){
  const collectors = countSymbol("collector");
  if(collectors<=0) return 0;

  let sum=0;
  [...grid.children].forEach(cell=>{
    if(cell.dataset.sym==="cashfish"){
      sum += Number(cell.dataset.val||0);
    }
  });

  if(sum<=0) return 0;
  return Math.round(sum * bonusMultiplier);
}

function applyCollectorProgress(collectorsThisSpin){
  if(collectorsThisSpin<=0) return;

  const before = bonusCollectorCount;
  bonusCollectorCount += collectorsThisSpin;

  if(before < COLLECTORS_FOR_X2 && bonusCollectorCount >= COLLECTORS_FOR_X2){
    freeSpinsLeft += EXTRA_FS_ON_MILESTONE;
    bonusMultiplier = Math.max(bonusMultiplier, 2);
    msg.textContent = `LEVEL UP! +${EXTRA_FS_ON_MILESTONE} FS â€¢ x${bonusMultiplier}`;
  }

  if(before < COLLECTORS_FOR_X3 && bonusCollectorCount >= COLLECTORS_FOR_X3){
    freeSpinsLeft += EXTRA_FS_ON_MILESTONE;
    bonusMultiplier = Math.max(bonusMultiplier, 3);
    msg.textContent = `LEVEL UP! +${EXTRA_FS_ON_MILESTONE} FS â€¢ x${bonusMultiplier}`;
  }
}

/* ================== SPIN ENGINE ================== */
function stopReelCycle(col){
  if(reelCycleTimers[col]){
    clearInterval(reelCycleTimers[col]);
    reelCycleTimers[col]=null;
  }
}

function startReelCycle(col){
  stopReelCycle(col);
  reelCycleTimers[col]=setInterval(()=>{
    // only update cells STILL marked spinning
    for(let row=0; row<ROWS; row++){
      const idx=row*COLS+col;
      const cell=grid.children[idx];
      if(!cell.classList.contains("spinning")) continue;

      const pool = (mode==="FreeSpins") ? symbolsFS : symbolsBase;
      setCellSymbol(cell, randFrom(pool));
    }
  }, SYMBOL_CYCLE_MS);
}

function spin(){
  if(spinning) return;
  if(mode==="Base" && balance<bet) return;

  spinning=true;

  // reset tease counter when a normal spin completes (not inside the tease chain)
  // (we keep it simple: let it persist until the next non-tease spin ends)
  spinCtx = {
    hasCollector:false,
    spawnCollector: (mode==="FreeSpins" && Math.random() < COLLECTOR_SPAWN_CHANCE_FS)
  };

  if(mode==="Base") balance -= bet;
  if(mode==="FreeSpins") freeSpinsLeft--;

  update();

  audio.spin.currentTime=0;
  safePlay(audio.spin);

  const cells=[...grid.children];

  // mark spinning and start reel cycles
  for(let col=0; col<COLS; col++){
    for(let row=0; row<ROWS; row++){
      cells[row*COLS+col].classList.add("spinning");
    }
    startReelCycle(col);
  }

  // stop reels one by one
  for(let col=0; col<COLS; col++){
    setTimeout(()=>{
      // stop cycling THIS reel first (fixes late symbol swaps)
      stopReelCycle(col);

      // finalize symbols for this reel
      for(let row=0; row<ROWS; row++){
        const idx=row*COLS+col;
        const cell=cells[idx];

        let sym;
        const pool = (mode==="FreeSpins") ? symbolsFS : symbolsBase;

        // spawn ONE collector on last reel in FS sometimes
        if(mode==="FreeSpins" && col===4 && spinCtx.spawnCollector && !spinCtx.hasCollector){
          sym="collector";
          spinCtx.hasCollector=true;
        }else{
          sym=randFrom(pool);
        }

        setCellSymbol(cell, sym);
        cell.classList.remove("spinning");
        cell.classList.add("stop");
        setTimeout(()=>cell.classList.remove("stop"),180);
      }

      // after last reel stops
      if(col===COLS-1){
        safePause(audio.spin);
        spinning=false;
        onSpinComplete();
      }
    }, REEL_START_SPIN_MS + col*REEL_GAP_MS);
  }
}

/* ================== RESULTS ================== */
function onSpinComplete(){
  const scatters = countSymbol("scatter");

  // BASE: trigger bonus
  if(mode==="Base" && scatters>=3){
    bonusIntroPending=true;
    msg.textContent="BONUS TRIGGERED!";
    update();
    showBonusIntro();
    return;
  }

  // BASE: tease respin
  if(mode==="Base" && teaseRespinsUsed < TEASE_MAX_RESPINS && teaseConditionMet()){
    teaseRespinsUsed++;
    msg.textContent="2 Scatters teaseâ€¦ Respin!";
    setTimeout(()=>{
      // free respin (refund the respin cost)
      balance += bet;
      spin();
    }, 650);
    return;
  }

  // FREE SPINS
  if(mode==="FreeSpins"){
    const collectorsThisSpin = countSymbol("collector");
    applyCollectorProgress(collectorsThisSpin);

    const win = collectCashfishIfCollectorPresent();
    lastWin = win;

    if(win>0){
      balance += win;
      msg.textContent = `COLLECT! Win Â£${win} (x${bonusMultiplier})`;
      animateWinTo(win);
      maybeBigWinOverlay(win);
    }else{
      msg.textContent = "Free Spinâ€¦";
      animateWinTo(0);
    }

    update();

    if(freeSpinsLeft>0){
      setTimeout(()=>spin(), 850);
    }else{
      setTimeout(()=>endBonus(), 700);
    }
    return;
  }

  // BASE: cluster pays
  const win = evaluateClustersWin();
  lastWin = win;

  if(win>0){
    balance += win;
    msg.textContent = `WIN Â£${win}`;
    animateWinTo(win);
    maybeBigWinOverlay(win);
  }else{
    msg.textContent="Ready. Get 3+ Scatter for Free Spins.";
    animateWinTo(0);
  }

  // reset tease counter after a completed base resolution
  teaseRespinsUsed = 0;

  update();
}

/* ================== STARTUP ================== */
createGrid();
update();
    </script>
