<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
  <meta name="theme-color" content="#07131b"/>
  <title>Fishing Splash Slots</title>

  <style>
    :root{
      --bg:#07131b;
      --panel: rgba(255,255,255,.10);
      --stroke: rgba(255,255,255,.18);
      --text:#f3fbff;
      --muted: rgba(243,251,255,.75);
      --gold:#ffcf5a;
      --aqua:#5fe1ff;
      --good:#7bffb2;
      --bad:#ff6b6b;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overscroll-behavior:none; touch-action:manipulation;
    }

    /* Underwater background (no images needed) */
    body::before{
      content:"";
      position:fixed; inset:0;
      background:
        radial-gradient(1100px 650px at 50% 10%, rgba(95,225,255,.35), transparent 55%),
        radial-gradient(900px 600px at 10% 90%, rgba(255,207,90,.18), transparent 60%),
        radial-gradient(900px 600px at 90% 85%, rgba(123,255,178,.16), transparent 60%),
        linear-gradient(180deg, #05202d 0%, #0b3a52 45%, #08202c 100%);
      z-index:-3;
    }
    /* Bubbles */
    body::after{
      content:"";
      position:fixed; inset:0;
      background-image:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,.16) 0 2px, transparent 3px),
        radial-gradient(circle at 40% 60%, rgba(255,255,255,.13) 0 3px, transparent 4px),
        radial-gradient(circle at 70% 35%, rgba(255,255,255,.13) 0 2px, transparent 3px),
        radial-gradient(circle at 85% 70%, rgba(255,255,255,.11) 0 3px, transparent 4px);
      background-size: 220px 220px, 280px 280px, 240px 240px, 320px 320px;
      opacity:.45;
      z-index:-2;
      animation: drift 14s linear infinite;
    }
    @keyframes drift{ from{ transform: translateY(0); } to{ transform: translateY(-80px); } }

    .wrap{
      min-height:100%;
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:12px;
      padding: calc(10px + env(safe-area-inset-top)) 12px calc(10px + env(safe-area-inset-bottom));
      max-width: 980px;
      margin: 0 auto;
    }

    .header{
      border-radius: 20px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(8px);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      position: relative;
      overflow:hidden;
    }
    .header::before{
      content:"";
      position:absolute; inset:-60px -60px auto -60px;
      height:120px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
      transform: rotate(12deg);
      opacity:.55;
    }
    .logoRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .title{ font-weight:1000; letter-spacing:.5px; font-size:22px; text-shadow:0 8px 24px rgba(0,0,0,.55); }
    .sub{ color:var(--muted); font-size:13px; margin-top:2px; }

    .pill{
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.20);
      border: 1px solid rgba(255,255,255,.18);
      display:flex; gap:8px; align-items:center;
      user-select:none;
    }
    .stats{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }

    .reels{
      border-radius: 22px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border: 1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 80px rgba(0,0,0,.45);
      position:relative;
      overflow:hidden;
    }
    .reels::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(800px 260px at 50% 0%, rgba(255,255,255,.18), transparent 60%);
      pointer-events:none;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
      position:relative;
      z-index:1;
    }

    .cell{
      border-radius: 18px;
      min-height: 86px;
      display:grid;
      place-items:center;
      border: 1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(80px 50px at 50% 20%, rgba(255,255,255,.12), transparent 65%),
        linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.25));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.10);
      position:relative;
      overflow:hidden;
    }

    .sym{
      font-size: clamp(26px, 6.6vw, 50px);
      font-weight: 1000;
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.55));
      letter-spacing: .5px;
    }
    .tag{
      position:absolute; top:8px; left:10px;
      font-size:11px; color:var(--muted);
      padding:3px 7px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      display:none;
    }
    .cash{
      position:absolute; bottom:8px; right:10px;
      font-size:12px; font-weight:1000;
      padding:3px 7px; border-radius:999px;
      border:1px solid rgba(255,207,90,.32);
      background:rgba(255,207,90,.10);
      color:rgba(255,207,90,.95);
      display:none;
    }

    .msg{
      margin-top:10px;
      padding: 12px 14px;
      border-radius: 18px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.14);
      color: var(--muted);
      display:flex; justify-content:space-between; gap:10px; align-items:center;
    }
    .msg strong{ color:var(--text); }

    .bottomBar{
      display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;
      padding: 12px;
      border-radius: 20px;
      background: rgba(0,0,0,.24);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(8px);
    }
    .btn{
      cursor:pointer;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color: var(--text);
      user-select:none;
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{
      background: radial-gradient(circle at 50% 30%, rgba(255,207,90,.55), rgba(255,207,90,.18));
      border-color: rgba(255,207,90,.55);
      font-weight: 1000;
      letter-spacing:.6px;
      min-width: 200px;
    }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    .winGlow{ outline: 2px solid rgba(95,225,255,.75); box-shadow: 0 0 0 6px rgba(95,225,255,.12); }
    .featureGlow{ outline: 2px solid rgba(255,207,90,.85); box-shadow: 0 0 0 6px rgba(255,207,90,.12); }
  </style>
</head>

<body>
<div class="wrap">

  <div class="header">
    <div class="logoRow">
      <div>
        <div class="title">FISHING SPLASH</div>
        <div class="sub">Big Bass-style: Free Spins + Collectors</div>
      </div>
      <div class="pill">Mode: <strong id="mode">Base</strong></div>
    </div>

    <div class="stats">
      <div class="pill">Balance: <strong id="bal">10000</strong></div>
      <div class="pill">Bet: <strong id="bet">100</strong></div>
      <div class="pill">Last Win: <strong id="last">0</strong></div>
    </div>
  </div>

  <div class="reels">
    <div class="grid" id="grid"></div>

    <div class="msg" id="msg">
      <span>Wild üÉè ‚Ä¢ Scatter üåü (3+ = Free Spins) ‚Ä¢ Cash Fish üêüüí∞ + Collector üé£ in Free Spins</span>
      <span style="font-size:13px;">For fun only</span>
    </div>
  </div>

  <div class="bottomBar">
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
      <button class="btn" id="betDown">-</button>
      <div class="pill">BET</div>
      <button class="btn" id="betUp">+</button>
      <button class="btn" id="maxBet">MAX</button>
      <button class="btn" id="mute">Sound: On</button>
    </div>

    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
      <button class="btn" id="auto">Auto: Off</button>
      <button class="btn primary" id="spin">SPIN</button>
    </div>
  </div>

</div>

<script>
(() => {
  // ----------------------------
  // Simple Big Bass-style slot
  // ----------------------------
  const REELS = 5, ROWS = 3;

  // Symbol types
  const Type = { REG:"REG", WILD:"WILD", SCAT:"SCAT", CASH:"CASH", COL:"COL" };

  // Regular symbols: includes BOTH letters/numbers and fishing items
  // pay: {3,4,5} multipliers (ways)
  const SYM = {
    // Letters / numbers
    A: {k:"A",  label:"A",  t:Type.REG, w:20, pay:{3:2,4:4,5:8}},
    K: {k:"K",  label:"K",  t:Type.REG, w:18, pay:{3:3,4:6,5:12}},
    Q: {k:"Q",  label:"Q",  t:Type.REG, w:16, pay:{3:4,4:8,5:16}},
    J: {k:"J",  label:"J",  t:Type.REG, w:14, pay:{3:5,4:10,5:20}},
    T: {k:"10", label:"10", t:Type.REG, w:12, pay:{3:6,4:12,5:24}},

    // Fishing items
    R: {k:"ROD",  label:"üé£", t:Type.REG, w:10, pay:{3:8,4:16,5:35}},
    B: {k:"BOAT", label:"üõ•Ô∏è", t:Type.REG, w:8,  pay:{3:10,4:22,5:50}},
    H: {k:"HOOK", label:"ü™ù", t:Type.REG, w:8,  pay:{3:10,4:22,5:55}},
    X: {k:"BOX",  label:"üß∞", t:Type.REG, w:7,  pay:{3:12,4:28,5:70}},

    // Special
    W: {k:"W", label:"üÉè", t:Type.WILD, w:6},
    S: {k:"S", label:"üåü", t:Type.SCAT, w:4},

    // Feature symbols (only used in free spins roll)
    $: {k:"$", label:"üêüüí∞", t:Type.CASH, w:0},
    C: {k:"C", label:"üé£",   t:Type.COL,  w:0} // collector
  };

  const REG_KEYS = ["A","K","Q","J","T","R","B","H","X"];
  const BASE_KEYS = [...REG_KEYS, "W", "S"];

  // Feature config
  const FREE_AWARD = {3:10, 4:15, 5:20};
  const RETRIG = {3:5, 4:8, 5:12};
  const CASH_VALUES = [1,1,2,2,3,4,5,6,8,10,12,15,20,25,30,40,50];

  const FS_CHANCE = {
    collector: 0.06,
    cash: 0.20,
    scatter: 0.06,
    wild: 0.08
  };

  // UI
  const gridEl = document.getElementById("grid");
  const balEl  = document.getElementById("bal");
  const betEl  = document.getElementById("bet");
  const lastEl = document.getElementById("last");
  const modeEl = document.getElementById("mode");
  const msgEl  = document.getElementById("msg");

  const spinBtn = document.getElementById("spin");
  const autoBtn = document.getElementById("auto");
  const betUpBtn = document.getElementById("betUp");
  const betDownBtn = document.getElementById("betDown");
  const maxBetBtn = document.getElementById("maxBet");
  const muteBtn = document.getElementById("mute");

  // Audio
  let audioCtx = null;
  let muted = false;
  function ensureAudio(){
    if (muted) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
  }
  function beep({freq=440,dur=0.08,type="sine",vol=0.06,slideTo=null}={}){
    if (muted) return;
    ensureAudio(); if(!audioCtx) return;
    const t0=audioCtx.currentTime;
    const osc=audioCtx.createOscillator();
    const gain=audioCtx.createGain();
    osc.type=type;
    osc.frequency.setValueAtTime(freq,t0);
    if(slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo,t0+dur);
    gain.gain.setValueAtTime(0.0001,t0);
    gain.gain.exponentialRampToValueAtTime(vol,t0+0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(t0); osc.stop(t0+dur+0.02);
  }
  const sfx = {
    spin: ()=>beep({freq:220,slideTo:360,dur:0.11,type:"triangle",vol:0.05}),
    stop: ()=>beep({freq:420,dur:0.05,type:"sine",vol:0.03}),
    tick: ()=>beep({freq:520,dur:0.03,type:"sine",vol:0.02}),
    win:  ()=>beep({freq:660,slideTo:990,dur:0.10,type:"triangle",vol:0.07}),
    big:  ()=>{beep({freq:880,slideTo:1320,dur:0.12,type:"sawtooth",vol:0.06}); setTimeout(()=>beep({freq:660,slideTo:990,dur:0.10,type:"triangle",vol:0.06}),85);},
    free: ()=>beep({freq:740,slideTo:1200,dur:0.16,type:"triangle",vol:0.07}),
    collect: ()=>beep({freq:520,slideTo:980,dur:0.14,type:"square",vol:0.06}),
    lose: ()=>beep({freq:220,slideTo:160,dur:0.14,type:"sine",vol:0.05})
  };

  // State
  const LS = "fishingsplash_easy_v1";
  const saved = JSON.parse(localStorage.getItem(LS) || "null");
  let balance = saved?.balance ?? 10000;
  let bet = saved?.bet ?? 100;
  muted = saved?.muted ?? false;

  let lastWin = 0;
  let auto = false;
  let spinning = false;

  let freeSpins = 0;
  let featureTotal = 0;

  // Each cell: {sym, cashMult}
  let grid = makeGrid();

  function save(){
    localStorage.setItem(LS, JSON.stringify({balance, bet, muted}));
  }
  function fmt(n){ return Math.max(0, Math.floor(n)).toString(); }

  function setMsg(text){
    msgEl.querySelector("span").innerHTML = text;
  }

  function renderTop(){
    balEl.textContent = fmt(balance);
    betEl.textContent = fmt(bet);
    lastEl.textContent = fmt(lastWin);
    modeEl.textContent = freeSpins>0 ? `Free Spins (${freeSpins})` : "Base";
    autoBtn.textContent = auto ? "Auto: On" : "Auto: Off";
    muteBtn.textContent = muted ? "Sound: Off" : "Sound: On";

    const cost = freeSpins>0 ? 0 : bet;
    spinBtn.disabled = spinning || balance < cost;
  }

  function makeGrid(){
    return Array.from({length:ROWS}, ()=>Array.from({length:REELS}, ()=>({sym:SYM.A, cashMult:0})));
  }

  function drawGrid(){
    gridEl.innerHTML = "";
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<REELS;c++){
        const cell = document.createElement("div");
        cell.className = "cell";

        const sym = document.createElement("div");
        sym.className = "sym";
        const s = grid[r][c].sym;
        sym.textContent = s.label;

        const tag = document.createElement("div");
        tag.className = "tag";
        if (s.t === Type.WILD) tag.textContent = "WILD";
        if (s.t === Type.SCAT) tag.textContent = "SCAT";
        if (s.t === Type.CASH) tag.textContent = "CASH";
        if (s.t === Type.COL)  tag.textContent = "COLLECT";
        if (tag.textContent) tag.style.display = "block";

        const cash = document.createElement("div");
        cash.className = "cash";
        if (s.t === Type.CASH){
          cash.style.display = "block";
          cash.textContent = "x" + grid[r][c].cashMult;
        }

        cell.appendChild(sym);
        cell.appendChild(tag);
        cell.appendChild(cash);
        gridEl.appendChild(cell);
      }
    }
  }

  function clearHighlights(){
    [...gridEl.children].forEach(el => el.classList.remove("winGlow","featureGlow"));
  }

  function highlight(pred, className){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<REELS;c++){
        if (pred(grid[r][c], r, c)){
          const idx = r*REELS + c;
          gridEl.children[idx]?.classList.add(className);
        }
      }
    }
  }

  // Weighted pick for base game
  const baseBag = (() => {
    const bag = [];
    for (const key of BASE_KEYS){
      const w = SYM[key].w || 1;
      for (let i=0;i<w;i++) bag.push(SYM[key]);
    }
    return bag;
  })();

  function pickBase(){
    return baseBag[(Math.random()*baseBag.length)|0];
  }
  function pickCashMult(){
    return CASH_VALUES[(Math.random()*CASH_VALUES.length)|0];
  }

  function rollCell(){
    // In free spins, sprinkle collector + cash fish + extra wilds/scatters
    if (freeSpins > 0){
      const roll = Math.random();
      if (roll < FS_CHANCE.collector) return {sym: SYM.C, cashMult:0};
      if (roll < FS_CHANCE.collector + FS_CHANCE.cash) return {sym: SYM.$, cashMult: pickCashMult()};
      if (roll < FS_CHANCE.collector + FS_CHANCE.cash + FS_CHANCE.scatter) return {sym: SYM.S, cashMult:0};
      if (roll < FS_CHANCE.collector + FS_CHANCE.cash + FS_CHANCE.scatter + FS_CHANCE.wild) return {sym: SYM.W, cashMult:0};

      const rk = REG_KEYS[(Math.random()*REG_KEYS.length)|0];
      return {sym: SYM[rk], cashMult:0};
    }

    // Base
    return {sym: pickBase(), cashMult:0};
  }

  // Animation: simple reel-by-reel stop
  function animateReel(reelIndex, finalCol, durationMs){
    return new Promise(resolve=>{
      const start = performance.now();
      let lastSwap = 0;
      function step(t){
        if (t - start >= durationMs){
          for(let r=0;r<ROWS;r++) grid[r][reelIndex] = finalCol[r];
          drawGrid();
          sfx.stop();
          resolve();
          return;
        }
        if (t - lastSwap > 55){
          for(let r=0;r<ROWS;r++) grid[r][reelIndex] = {sym: pickBase(), cashMult:0};
          drawGrid();
          if (Math.random()<0.35) sfx.tick();
          lastSwap = t;
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    });
  }

  async function spinReels({fast=false}={}){
    const finals = Array.from({length:REELS}, ()=>Array.from({length:ROWS}, ()=>rollCell()));
    const base = fast ? 260 : 540;
    const stagger = fast ? 80 : 140;
    sfx.spin();
    await Promise.all(
      Array.from({length:REELS}, (_,i)=>animateReel(i, finals[i], base + stagger*i))
    );
  }

  // WAYS win calc for REG symbols (wild substitutes)
  function evalWays(){
    const wins = [];
    for(const key of REG_KEYS){
      const target = SYM[key];
      const counts = [];
      for(let c=0;c<REELS;c++){
        let count = 0;
        for(let r=0;r<ROWS;r++){
          const s = grid[r][c].sym;
          if (s === target || s.t === Type.WILD) count++;
        }
        counts.push(count);
        if (count === 0) break;
      }
      let len = 0;
      for(let i=0;i<counts.length;i++){ if(counts[i]>0) len++; else break; }
      if (len >= 3){
        const ways = counts.slice(0,len).reduce((a,b)=>a*b,1);
        const pay = target.pay[len] || 0;
        const amount = ways * pay * bet;
        if (amount>0) wins.push({key, len, ways, amount});
      }
    }
    wins.sort((a,b)=>b.amount-a.amount);
    return wins;
  }

  function countType(t){
    let n=0;
    for(let r=0;r<ROWS;r++) for(let c=0;c<REELS;c++) if(grid[r][c].sym.t===t) n++;
    return n;
  }

  function collectFish(){
    const collectors = countType(Type.COL);
    if (collectors <= 0) return 0;

    let fishTotal = 0;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<REELS;c++){
        if (grid[r][c].sym.t === Type.CASH){
          fishTotal += grid[r][c].cashMult * bet;
        }
      }
    }
    if (fishTotal <= 0) return 0;

    // each collector collects once
    const collected = fishTotal * collectors;

    // clear cash fish after collecting
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<REELS;c++){
        if (grid[r][c].sym.t === Type.CASH){
          const rk = REG_KEYS[(Math.random()*REG_KEYS.length)|0];
          grid[r][c] = {sym: SYM[rk], cashMult:0};
        }
      }
    }
    drawGrid();

    clearHighlights();
    highlight(cell => cell.sym.t===Type.COL, "featureGlow");
    sfx.collect();

    return collected;
  }

  function rollup(amount){
    if (amount <= 0) return Promise.resolve();
    const start = performance.now();
    const dur = Math.min(1100, 280 + Math.log10(amount+1)*420);
    const from = 0;
    return new Promise(resolve=>{
      function step(t){
        const p = Math.min(1, (t-start)/dur);
        const eased = 1 - Math.pow(1-p, 3);
        lastEl.textContent = fmt(from + amount*eased);
        if (p<1) requestAnimationFrame(step);
        else resolve();
      }
      requestAnimationFrame(step);
    });
  }

  async function spinOnce({fast=false}={}){
    if (spinning) return;
    ensureAudio();
    spinning = true;
    clearHighlights();
    lastWin = 0;
    renderTop();

    const isFree = freeSpins > 0;
    const cost = isFree ? 0 : bet;
    if (balance < cost){
      spinning = false;
      setMsg("Not enough balance.");
      sfx.lose();
      renderTop();
      return;
    }

    if (isFree) freeSpins--;
    else balance -= bet;

    renderTop();
    await spinReels({fast});

    // base ways wins
    let total = 0;
    const wins = evalWays();
    if (wins.length){
      total += wins.reduce((s,w)=>s+w.amount,0);
      // highlight top win symbol + wilds
      const top = wins[0].key;
      highlight(cell => cell.sym === SYM[top] || cell.sym.t===Type.WILD, "winGlow");
    }

    // scatters trigger/retrigger
    const scat = countType(Type.SCAT);
    if (scat >= 3){
      highlight(cell => cell.sym.t===Type.SCAT, "featureGlow");
      const add = isFree ? (RETRIG[scat]||0) : (FREE_AWARD[scat]||0);
      if (add){
        freeSpins += add;
        setMsg(`üåü ${scat} Scatters! +${add} Free Spins`);
        sfx.free();
      }
    }

    // collectors collect cash fish in free spins
    if (isFree){
      const collected = collectFish();
      if (collected > 0){
        total += collected;
        setMsg(`üé£ Collector collected <strong>${fmt(collected)}</strong> from Cash Fish`);
      }
    }

    // payout
    if (total > 0){
      balance += total;
      lastWin = total;
      if (isFree) featureTotal += total;
      (total >= bet*60 ? sfx.big : sfx.win)();
      await rollup(total);

      setMsg(isFree
        ? `WIN <strong>${fmt(total)}</strong> ‚Ä¢ Free Spins left: <strong>${freeSpins}</strong>`
        : `WIN <strong>${fmt(total)}</strong>`);
    } else {
      sfx.lose();
      setMsg(isFree
        ? `No win ‚Ä¢ Free Spins left: <strong>${freeSpins}</strong>`
        : "No win.");
    }

    // end of feature
    if (isFree && freeSpins === 0){
      setMsg(`Free Spins complete. Feature total: <strong>${fmt(featureTotal)}</strong>`);
      featureTotal = 0;
    }

    spinning = false;
    save();
    renderTop();

    if (auto){
      await new Promise(r=>setTimeout(r, fast?80:220));
      spinOnce({fast});
    }
  }

  // Controls
  function setBet(n){
    bet = Math.max(50, Math.min(n, 500));
    save();
    renderTop();
  }
  spinBtn.addEventListener("click", ()=>spinOnce());
  autoBtn.addEventListener("click", ()=>{
    ensureAudio();
    auto = !auto;
    renderTop();
    if (auto && !spinning) spinOnce();
  });
  betUpBtn.addEventListener("click", ()=>{ ensureAudio(); if(!spinning) setBet(bet+50); });
  betDownBtn.addEventListener("click", ()=>{ ensureAudio(); if(!spinning) setBet(bet-50); });
  maxBetBtn.addEventListener("click", ()=>{ ensureAudio(); if(!spinning) setBet(500); });
  muteBtn.addEventListener("click", ()=>{
    ensureAudio();
    muted = !muted;
    save();
    renderTop();
  });

  // Hold to fast spin on mobile
  let holding=false, holdTimer=null;
  spinBtn.addEventListener("pointerdown",(e)=>{
    if (e.pointerType==="mouse") return;
    holding=true;
    holdTimer=setTimeout(()=>{ if(holding && !spinning) spinOnce({fast:true}); }, 220);
  });
  const endHold=()=>{ holding=false; if(holdTimer) clearTimeout(holdTimer); holdTimer=null; };
  spinBtn.addEventListener("pointerup", endHold);
  spinBtn.addEventListener("pointercancel", endHold);
  spinBtn.addEventListener("pointerleave", endHold);

  // init
  document.addEventListener("pointerdown", ()=>ensureAudio(), {once:true});
  grid = makeGrid();
  for(let c=0;c<REELS;c++) for(let r=0;r<ROWS;r++) grid[r][c] = {sym: pickBase(), cashMult:0};
  drawGrid();
  setMsg("Ready. Get 3+ üåü for Free Spins. In Free Spins, üé£ collects üêüüí∞ values.");
  renderTop();
  save();
})();
</script>
</body>
</html>
